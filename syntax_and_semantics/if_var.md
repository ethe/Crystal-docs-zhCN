# if 变量

如果一个变量与 `if` 条件有关，经过 `then` 分之之后，此变量将不再只是 `Nil` 类型，与其返回值有关。

```crystal
a = some_condition ? nil : 3
# a 是 Int32 或 Nil

if a
  # 因为运行到这里 a 必然为 truthy,
  # a 不可能为 nil, 所有这里 a 必定为 Int32。
  a.abs
end
```

也同样适用于在 `if` 条件中进行变量赋值:

```crystal
if a = some_expression
  # a 不为 nil
end
```

这种逻辑同样适用于 `if` 条件的与操作(`&&`):

```crystal
if a && b
  # 这里，a 和 b 都不为 Nil
end
```

这里, 右边的 `&&` 表达式确保 `a` 为非 `Nil` 类型。

当然, 在 `then` 分之里面对变量进行再赋值，那么变量类型将取决于赋值的表达式。

以上逻辑将 **不适用** 于类实例变量, 类变量以及全局变量:

```crystal
if @a
  # 这里 @a 有可能为 nil
end
```

这是因为所有方法调用都有可能改变实例变量的值， 被重新赋值为 `nil`。 另外一个原因是其他线程在检查这个条件的时候改变这个实例变量。

你有两种方式确保使用一个非 `nil` 的实例变量 `@a` :

```crystal
# 第一种: 赋值给一局部变量
if a = @a
  # 这里不为空
end

# 第二种: 使用标准库的 `Object#try`
@a.try do |a|
  # 这里也不为空
end
```

上述逻辑不适用于代码块和方法调用, 包括 getters 和属性, 因为在两个连续调用中，nilable (或者更一般地，集合型) 的过程和方法并不保证能返回相同的更特定的类型。

```crystal
if method # 第一个方法调用返回 Int32 或者 Nil
          # 这里我们知道第一个方法调用返回不为空
  method  # 第二个方法调用返回也为 Int32 或者 Nil
end
```
上述实例变量技术描述也同样适用于代码块和方法调用。
